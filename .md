## Next.js Theory Used In This Workspace

### What is Next.js?
- Definition: A React framework for building web apps with file‑based routing, hybrid rendering (SSG/SSR/ISR), Server Components, and full‑stack features like API routes and Server Actions.
- Why use it: Faster DX and performance: routing, data fetching, caching, image optimization, and deployment patterns are built in.

---

This file is a concise theory-only cheatsheet of the Next.js concepts actually used in the two apps (`routing` and `snippets-project`).

---

### App Router Basics
- Files live under `app/`. Each folder is a route segment.
- `page.tsx` renders the route for that segment.
- `layout.tsx` wraps all nested routes and persists across navigations.
- Default components are Server Components. Add `"use client"` to opt into Client Components when you need interactivity.

Definition / Use / Example
- Definition: The App Router is Next.js’s routing system using the `app/` directory.
- Use when: Building pages, layouts, and nested UIs with React Server Components by default.
- Example:
  - Structure: `app/page.tsx` → `/`, `app/dashboard/page.tsx` → `/dashboard`
  - Layout: `app/layout.tsx` persists header/footer across routes

---

### Routing Conventions You Used
- Root route: `app/page.tsx` → `/`.
- Static routes: `app/performance/page.tsx`, `app/reliability/page.tsx` → `/performance`, `/reliability`.
- Dynamic routes: `app/snippets/[id]/page.tsx` → `/snippets/:id`.
- Nested routes: `app/snippets/[id]/edit/page.tsx` → `/snippets/:id/edit`.
- Segment-level boundaries: `loading.tsx` and `not-found.tsx` under `app/snippets/[id]/`.

Definition / Use / Example
- Definition: File names map to URLs; brackets create dynamic params.
- Use when: You need readable URLs and per‑segment behaviors (loading, errors, not found).
- Example:
  - `app/posts/[slug]/page.tsx` receives `params.slug`
  - `app/posts/[slug]/not-found.tsx` renders when `notFound()` is thrown

---

### Special Segment Files
- `layout.tsx`: Shared UI shell (headers, providers, styles) that persists.
- `page.tsx`: The content of a specific route.
- `loading.tsx`: Immediate loading UI during server work (streaming + Suspense).
- `not-found.tsx`: 404 boundary for missing data; triggered by `notFound()`.
- `error.tsx` (optional): Error boundary for a segment with a `reset()` handler.
- `metadata` (via export or `head.tsx`): Title, description, OG tags.

Definition / Use / Example
- Definition: Conventional files that control rendering, UX, and SEO per segment.
- Use when: You need persistent layout, graceful loading, custom 404, or localized error handling.
- Example:
  - `export const metadata = { title: 'Home' }` in `page.tsx`
  - `export default function Loading(){ return <p>Loading...</p> }` in `loading.tsx`

---

### Server vs Client Components
- Server Components (default): Run on server, can fetch data directly, no client JS bundle cost. Great for data-heavy UI.
- Client Components (`"use client"`): Enable hooks (`useState`, `useEffect`), event handlers, and browser APIs. Use sparingly around interactive parts.
- Composition: Server Components can render Client Components as children.

Definition / Use / Example
- Definition: Two component types with different runtimes and capabilities.
- Use when: Server for data-heavy/non-interactive UI; Client for interactivity and browser APIs.
- Example:
  - Server: `export default async function Page(){ const data = await fetch(...); return <List data={data}/> }`
  - Client: `"use client"; export function Counter(){ const [n,setN]=useState(0); return <button onClick={()=>setN(n+1)}>{n}</button> }`

---

### Data Fetching, Caching, and Revalidation
- Use `await fetch(...)` in Server Components for data.
- Static Generation (SSG): default when data is cacheable.
- Dynamic Rendering (SSR): mark requests with `{ cache: 'no-store' }` or read headers/cookies.
- Incremental Static Regeneration (ISR): `{ next: { revalidate: N } }` to refresh after N seconds.
- Fetch defaults: requests are cached and deduped automatically during render.

Cheatsheet:
- Cache forever: `fetch(url, { cache: 'force-cache' })`.
- Never cache: `fetch(url, { cache: 'no-store' })`.
- Revalidate: `fetch(url, { next: { revalidate: seconds } })`.

Definition / Use / Example
- Definition: Next.js controls response caching at the fetch call site to choose SSG/SSR/ISR.
- Use when: You need predictable freshness and performance per request.
- Example:
  - ISR: `await fetch(api, { next: { revalidate: 60 } })` revalidates every 60s
  - SSR: `await fetch(api, { cache: 'no-store' })` renders on each request

---

### Server Actions (Used for CRUD)
- Mark functions with `'use server'` to run only on the server.
- Call them from forms: `<form action={myAction}>` or programmatically.
- Good for create/update/delete flows; direct access to server-side resources and secrets.
- UX helpers: `useFormStatus()` in a Client Component to show pending states.

Definition / Use / Example
- Definition: Server-only functions that can be invoked directly from components or forms.
- Use when: Performing mutations (e.g., Prisma create/update/delete) without a separate API route.
- Example:
  - `'use server'; export async function create(data){ /* DB write */ }`
  - `<form action={create}><input name="title"/></form>`

---

### Navigation
- Declarative: `<Link href="/path">` for client-side transitions.
- Imperative (in Client Components): `const router = useRouter(); router.push('/path')`.

Definition / Use / Example
- Definition: Client-side routing primitives for fast transitions.
- Use when: Linking between pages or navigating after actions.
- Example:
  - `<Link href="/snippets/new">New</Link>`
  - `router.replace('/snippets/' + id)`

---

### Streaming and Suspense
- Server Components stream HTML by default for fast time-to-first-byte.
- `loading.tsx` provides instant feedback while a segment is loading.
- Wrap slow children with `Suspense` boundaries if needed.

Definition / Use / Example
- Definition: Incrementally send UI as it’s ready; show fallbacks during async work.
- Use when: Parts of a route load data more slowly than others.
- Example:
  - `export default function Loading(){ return <Spinner/> }`

---

### Error and 404 Handling
- 404: Use `notFound()` from `next/navigation` to render the nearest `not-found.tsx`.
- Errors: Place `error.tsx` in a segment to catch errors below; Next gives a `reset()` you can call to retry.

Definition / Use / Example
- Definition: Per-segment boundaries for failures and missing data.
- Use when: Fetch fails or an item doesn’t exist (e.g., missing snippet ID).
- Example:
  - `if (!post) notFound()`
  - In `error.tsx`: `export default function Error({ reset }){ return <button onClick={reset}>Retry</button> }`

---

### Assets and Images
- Public assets go in `public/` and are served from `/<filename>`.
- Prefer `next/image` for automatic image optimization when using images in components.

Definition / Use / Example
- Definition: Static files live under `public` and are served as-is; `next/image` optimizes images.
- Use when: You need logos, icons, or optimized images in UI.
- Example: `<Image src="/hero.jpg" alt="Hero" width={800} height={400}/>`

---

### Styling Integration
- Tailwind CSS via PostCSS plugin with global styles in `app/globals.css`.
- CSS Modules are also supported using `*.module.css` files for component-scoped styles.

Definition / Use / Example
- Definition: Styling approaches supported by Next.js out of the box.
- Use when: You want utility-first styling (Tailwind) or scoped styles (CSS Modules).
- Example:
  - Globals: define base styles in `app/globals.css`
  - Modules: `import s from './button.module.css'`

---

### Environment Variables (Used on Server)
- Access server-only secrets with `process.env.*` in Server Components/Actions.
- Expose safe values to the client by prefixing with `NEXT_PUBLIC_`.

Definition / Use / Example
- Definition: Build/runtime configuration via env vars.
- Use when: Storing DB URLs, API keys (server-only) or public config (with `NEXT_PUBLIC_`).
- Example:
  - Server: `const url = process.env.DATABASE_URL`
  - Client: `process.env.NEXT_PUBLIC_API_BASE`

---

### Practical Mental Model (What You Practiced)
- Structure UI with `layout.tsx` + route `page.tsx` files.
- Use dynamic segments for IDs and show edit/detail pages.
- Show instant feedback with `loading.tsx` and handle missing data with `not-found.tsx`.
- Keep interactivity in small Client Components; do data work in Server Components.
- Perform mutations through Server Actions tied to forms.

